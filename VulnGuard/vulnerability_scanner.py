import os
import json
import subprocess
import re
import sys
import logging

# Constants
REQUIREMENTS_TXT = 'requirements.txt'
PACKAGE_JSON = 'package.json'

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Mock data for vulnerabilities
MOCK_VULNERABILITIES = {
    "requests": {
        "vulnerabilities": [
            {
                "id": "CVE-2021-33503",
                "description": "The requests package before 2.25.1 for Python sends an HTTP Authorization header to an http URI upon receiving a same-hostname https-to-http redirect, which makes it easier for remote attackers to discover credentials by sniffing the network."
            }
        ],
        "fixed_version": "2.25.1",
        "url": "https://nvd.nist.gov/vuln/detail/CVE-2021-33503"
    },
    "flask": {
        "vulnerabilities": [
            {
                "id": "CVE-2019-1010083",
                "description": "The Pallets Project Flask before 1.0 is affected by: unexpected memory usage. The impact is: denial of service. The attack vector is: crafted encoded JSON data. The fixed version is: 1.0."
            }
        ],
        "fixed_version": "1.0",
        "url": "https://nvd.nist.gov/vuln/detail/CVE-2019-1010083"
    }
}

def read_requirements_txt(file_path):
    with open(file_path, 'r') as file:
        return [line.strip() for line in file if line.strip() and not line.startswith('#')]

def read_package_json(file_path):
    try:
        with open(file_path, 'r') as file:
            data = json.load(file)
        return data.get('dependencies', {})  # Return empty dict if 'dependencies' is not present
    except FileNotFoundError:
        logger.error(f"File not found: {file_path}")
        return {}  # Return empty dictionary if file not found
    except json.JSONDecodeError as e:
        logger.error(f"Error parsing JSON in {file_path}: {e}")
        return {}  # Return empty dictionary if JSON is malformed

def query_vulnerabilities(dependencies):
    vulnerabilities = {}
    for dependency, version in dependencies.items():
        vulnerabilities[dependency] = []
        try:
            result = subprocess.run(['searchsploit', dependency], capture_output=True, text=True, check=True, timeout=10)
            matches = re.findall(r"^(.*?)\s*\|\s*(.*?)$", result.stdout, re.MULTILINE)
            for match in matches:
                if match[0] and match[1] and "Exploit Title" not in match[0]:
                    if dependency in match[0]:  # Ensure the vulnerability is for the correct dependency
                        vuln_info = {
                            "id": match[0].strip(),
                            "description": match[1].strip(),
                        }
                        if MOCK_VULNERABILITIES.get(dependency):
                            vuln_info["fixed_version"] = MOCK_VULNERABILITIES[dependency].get("fixed_version")
                            vuln_info["url"] = MOCK_VULNERABILITIES[dependency].get("url")
                        else:
                            logger.warning(f"No vulnerability information found for {dependency}")
                        vulnerabilities[dependency].append(vuln_info)
        except subprocess.CalledProcessError as e:
            logger.error(f"Error running searchsploit for {dependency}: {e}")
        except FileNotFoundError:
            logger.error(f"searchsploit command not found. Please ensure it is installed and available in your PATH.")
        except PermissionError:
            logger.error(f"Permission denied when running searchsploit for {dependency}. Please check your permissions.")
        except subprocess.TimeoutExpired:
            logger.error(f"Timeout expired when running searchsploit for {dependency}. Please try again.")
        except Exception as e:
            logger.error(f"Unexpected error querying {dependency}: {e}")
    return vulnerabilities

def generate_report(vulnerabilities):
    report = []
    for dep, vulns in vulnerabilities.items():
        report.append(f"Dependency: {dep}")
        for vuln in vulns:
            report.append(f" - Vulnerability: {vuln['id']}")
            report.append(f"   Description: {vuln['description']}")
        report.append("")
    return "\n".join(report)

def main():
    dependencies = {}

    # Read requirements.txt
    if os.path.exists(REQUIREMENTS_TXT):
        dependencies.update({dep.split('==')[0]: dep.split('==')[1] for dep in read_requirements_txt(REQUIREMENTS_TXT)})

    # Read package.json
    if os.path.exists(PACKAGE_JSON):
        dependencies.update(read_package_json(PACKAGE_JSON))

    # Query vulnerabilities
    vulnerabilities = query_vulnerabilities(dependencies)

    # Generate report
    report = generate_report(vulnerabilities)
    print(report)

if __name__ == "__main__":
    main()